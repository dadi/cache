<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" DADI Cache Classes CacheFileCacheRedisCache Source: index.js var contract = require('dbc') var FileCache = require('./file') var RedisCache = require('./redis') var _ = require('underscore') var log = require('@dadi/logger') log.init({ enabled: true, level: 'warn', filename: 'cache', extension: '.log' }) /** * Creates a new Cache instance * @constructor * @param {object} [options={ directory: { enabled: true, path: './cache' }, redis: { enabled: false } }] - the options used to instantiate Cache Handlers * @example * var Cache = require('@dadi/cache') * var cache = new Cache({ * &quot;ttl&quot;: 3600, * &quot;directory&quot;: { * &quot;enabled&quot;: false, * &quot;path&quot;: &quot;./cache/&quot; * }, * &quot;redis&quot;: { * &quot;enabled&quot;: true, * &quot;host&quot;: &quot;127.0.0.1&quot;, * &quot;port&quot;: 6379 * } * }) */ function Cache (options) { contract.check(options, { directory: [ { validator: 'required'}, { validator:'type', args: ['object']}], redis: [ { validator: 'required'}, { validator:'type', args: ['object']}] // type: [{validator: 'required'}, {validator: 'custom', args:[function x() { // if (options.type === 'directory' &amp;&amp; !options.path) return false // if (options.type === 'redis' &amp;&amp; !options.host) return false // if (options.type === 'redis' &amp;&amp; !options.port) return false // return true // }]}] }) this.options = options this.cacheHandlers = {} this.enabled = options.directory.enabled || options.redis.enabled // get the first cache type from the options with { enabled: true } this.type = _.findKey(options, (option) =&gt; { return option.enabled }) switch (this.type) { case 'directory': this.cacheHandler = this.createFileCache(options.directory, options.ttl) break case 'redis': this.cacheHandler = this.createRedisCache(options.redis, options.ttl) break default: this.cacheHandler = this.createFileCache(options.directory, options.ttl) } } /** * Get an item from the cache * @param {String} key - the key used to reference the item in the cache * @returns {Promise.&lt;Stream, Error&gt;} A promise that returns a Stream if the key exists, * or an Error if it does not exist */ Cache.prototype.get = function (key) { return this.cacheHandler.get(key) } /** * Add an item to the cache * @param {String} key - the key used to reference the item in the cache * @param {Buffer|Stream|String} data - the data to store in the cache * @returns {Promise.&lt;String, Error&gt;} A promise that returns an empty String if successful, otherwise an Error */ Cache.prototype.set = function (key, data) { return this.cacheHandler.set(key, data) } /** * Instantiates a FileCache and adds it to the set of CacheHandlers * @param {object} options - the options used to create a FileCache instance, specifically `path` which determines where cached data will be stored * @param {Number} ttl - the time in seconds after which a cached item should be considered stale * @returns {FileCache} */ Cache.prototype.createFileCache = function (options, ttl) { options.ttl = ttl var handler = new FileCache(options) this.cacheHandlers.directory = handler return handler } /** * Instantiates a RedisCache and adds it to the set of CacheHandlers * @param {object} options - the options used to create a RedisCache instance, specifically `host` and `port` for connecting to a Redis server * @param {Number} ttl - the time in seconds after which Redis should expire a cached item * @returns {RedisCache} */ Cache.prototype.createRedisCache = function (options, ttl) { options.ttl = ttl var handler = new RedisCache(options) handler.on('ready', () =&gt; { // when we are connected if (this.cacheHandler.constructor.name === 'FileCache') { this.cacheHandler = this.cacheHandlers.redis } log.warn('REDIS connected') }) handler.on('end', () =&gt; { // should fire only on graceful dc log.warn('REDIS disconnecting') }) handler.on('reconnecting', function (attempt) { // every attempt log.warn('REDIS reconnecting, attempt #' + attempt.attempt) }) handler.on('fail', () =&gt; { log.warn('REDIS connection failed') log.warn('Falling back to filesystem caching at ' + this.options.directory.path) if (!this.cacheHandlers.directory) { this.createFileCache(this.options.directory, this.options.ttl) } this.cacheHandler = this.cacheHandlers.directory }) this.cacheHandlers.redis = handler return handler } /** * */ module.exports = function (options) { return new Cache(options || { directory: { enabled: true, path: './cache' }, redis: { enabled: false } } ) } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"file.js.html":{"id":"file.js.html","title":"Source: file.js","body":" DADI Cache Classes CacheFileCacheRedisCache Source: file.js var fs = require('fs') var mkdirp = require('mkdirp') var path = require('path') var Stream = require('stream') var streamifier = require('streamifier') /** * Creates a new FileCache instance * @constructor * @classdesc This is a description of the FileCache. * @param {object} options - the options used to instantiate a FileCache handler */ function FileCache (options) { this.directory = options.path this.extension = options.extension ? '.' + options.extension : '' this.ttl = options.ttl || 3600 this.encoding = 'utf-8' mkdirp(this.directory, (err, made) =&gt; { // if (err) log.error({module: 'cache'}, err) // if (made) log.info({module: 'cache'}, 'Created cache directory ' + made) }) } /** * @param {String} key - the key to retrieve from cache * @returns {Promise.&lt;Stream, Error&gt;} A promise that returns a Stream if the key exists, * or an Error if it does not exist */ FileCache.prototype.get = function (key) { return new Promise((resolve, reject) =&gt; { var cachePath = path.resolve(path.join(this.directory, key + this.extension)) fs.stat(cachePath, (err, stats) =&gt; { if (err) { return reject(new Error('The specified key does not exist')) } var lastModified = stats &amp;&amp; stats.mtime &amp;&amp; stats.mtime.valueOf() if (this.ttl &amp;&amp; lastModified &amp;&amp; (Date.now() - lastModified) / 1000 &lt;= this.ttl) { var stream = fs.createReadStream(cachePath) return resolve(stream) } else { return reject(new Error('The specified key has expired')) } }) }) } /** * @param {String} key - the key to store the data against * @param {String|Buffer|Stream} data - the data to cache, as a String, Buffer or Stream * @returns {Promise.&lt;String, Error&gt;} A promise that returns an empty String if successful, otherwise an Error */ FileCache.prototype.set = function (key, data) { return new Promise((resolve, reject) =&gt; { var cachePath = path.resolve(path.join(this.directory, key + this.extension)) // open a stream for writing the data var cacheFile = fs.createWriteStream(cachePath, { flags: 'w', defaultEncoding: this.encoding }) cacheFile.on('finish', () =&gt; { return resolve('') }).on('error', (err) =&gt; { return reject(err) }) var stream // create a stream from the data if it is a String or Buffer if (data instanceof Buffer || typeof data === 'string') { stream = streamifier.createReadStream(data) } else if (data instanceof Stream) { stream = data } stream.pipe(cacheFile) }) } /** * */ module.exports = function (options) { return new FileCache(options) } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"redis.js.html":{"id":"redis.js.html","title":"Source: redis.js","body":" DADI Cache Classes CacheFileCacheRedisCache Source: redis.js var EventEmitter = require('events') var log = require('@dadi/logger') var redis = require('redis') var redisRStream = require('redis-rstream') var redisWStream = require('redis-wstream') var Stream = require('stream') var streamifier = require('streamifier') var util = require('util') /** * Creates a new RedisCache instance * @constructor * @classdesc This is a description of the RedisCache. * @param {object} options - the options used to instantiate a RedisCache handler */ function RedisCache (options) { this.options = options this.ttl = options.ttl || 3600 this.redisClient = this.initialise(options) EventEmitter.call(this) } util.inherits(RedisCache, EventEmitter) /** * @param {String} key - the key to retrieve from cache * @returns {Promise.&lt;Stream, Error&gt;} A promise that returns a Stream if the key exists, * or an Error if it does not exist */ RedisCache.prototype.get = function (key) { return new Promise((resolve, reject) =&gt; { this.redisClient.exists(key, (err, exists) =&gt; { if (exists &gt; 0) { var stream = redisRStream(this.redisClient, key) return resolve(stream) } else { return reject(new Error('The specified key does not exist')) } }) }) } /** * @param {String} key - the key to store the data against * @param {String|Buffer|Stream} data - the data to cache, as a String, Buffer or Stream * @returns {Promise.&lt;String, Error&gt;} A promise that returns an empty String if successful, otherwise an Error */ RedisCache.prototype.set = function (key, data) { return new Promise((resolve, reject) =&gt; { var redisWriteStream = redisWStream(this.redisClient, key) redisWriteStream.on('finish', () =&gt; { if (this.ttl) { this.redisClient.expire(key, this.ttl) } return resolve('') }).on('error', (err) =&gt; { return reject(err) }) var stream // create a stream from the data if it is a String or Buffer if (data instanceof Buffer || typeof data === 'string') { stream = streamifier.createReadStream(data) } else if (data instanceof Stream) { stream = data } stream.pipe(redisWriteStream) }) } /** * Initialises a RedisClient using the main configuration settings * @returns {RedisClient} */ RedisCache.prototype.initialise = function (options) { var self = this function retryStrategy (options) { var baseRetryTime = 1024 var maxRetryTime = 4096 var maxConnectedTimes = 3 var currentRetryTime = baseRetryTime * options.attempt if (currentRetryTime &gt; maxRetryTime) { self.onFailure() return new Error('Exceeded max retry time') } if (options.times_connected &gt; maxConnectedTimes) { self.onFailure() return new Error('Exceeded max times connected; Redis appears unstable') } return currentRetryTime } var redisClient = redis.createClient(options.port, options.host, {detect_buffers: true, retry_strategy: retryStrategy}) redisClient.on('error', function (err) { // Doesn't get fired on dc errors log.error(err) }) redisClient.on('end', () =&gt; { // should fire only on graceful dc this.emit('end') }) redisClient.on('ready', () =&gt; { // when we are connected this.emit('ready') }) redisClient.on('reconnecting', (attempt) =&gt; { // every attempt this.emit('reconnecting', attempt) }) return redisClient } RedisCache.prototype.onFailure = function () { var redisRetryTime = 1000 * 60 * 1 this.emit('fail') // create an event to try redis again setTimeout(() =&gt; { log.warn('REDIS attempting reconnection') this.redisClient = this.initialise(this.options) }, redisRetryTime) } module.exports = function (options) { return new RedisCache(options) } × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DADI Cache Classes CacheFileCacheRedisCache Classes Classes Cache FileCache RedisCache × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" DADI Cache Classes CacheFileCacheRedisCache DADI Cache OverviewInstallnpm install @dadi/cache --saveUsageCreate Cache instance{@lang javascript} // require the module var Cache = require('@dadi/cache') // setup the options for caching // default if not specified: { directory: { enabled: true, path: './cache' }, redis: { enabled: false } } var options = { &quot;ttl&quot;: 3600, &quot;directory&quot;: { &quot;enabled&quot;: false, &quot;path&quot;: &quot;./cache/&quot; }, &quot;redis&quot;: { &quot;enabled&quot;: true, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 6379 } } var cache = new Cache(options)Add an item to the cacheset(key, data)Returns a Promise that returns an empty String if successful, otherwise an Error. The data argument can be a String, Buffer or Stream. {@lang javascript} var key = 'test-cached-item' var data = 'test data' cache.set(key, data).then(() =&gt; { // do something }).catch((err) =&gt; { // Error })Get an item from the cacheget(key)Returns a Promise that returns a Stream of the cached data if the key exists or an Error if it does not exist. The error message returned is &quot;The specified key does not exist&quot;. {@lang javascript} var key = 'test-cached-item' cache.get(key).then((stream) =&gt; { // do something with the stream }).catch((err) =&gt; { // &quot;The specified key does not exist&quot; })Example usage{@lang javascript} var Cache = require('@dadi/cache') var cache = new Cache() app.use(function (req, res, next) { cache.get(req.url).then((stream) =&gt; { // cached data found for req.url res.setHeader('X-Cache', 'HIT') stream.pipe(res) }).catch((err) =&gt; { // cached data not found for req.url var content = fetchContent() res.setHeader('X-Cache', 'MISS') res.end(content) }) }) × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"Cache.html":{"id":"Cache.html","title":"Class: Cache","body":" DADI Cache Classes CacheFileCacheRedisCache Class: Cache Cache new Cache( [options]) Creates a new Cache instance Parameters: Name Type Argument Default Description options object &lt;optional&gt; { directory: { enabled: true, path: './cache' }, redis: { enabled: false } } the options used to instantiate Cache Handlers Source: index.js, line 33 Example var Cache = require('@dadi/cache') var cache = new Cache({ &quot;ttl&quot;: 3600, &quot;directory&quot;: { &quot;enabled&quot;: false, &quot;path&quot;: &quot;./cache/&quot; }, &quot;redis&quot;: { &quot;enabled&quot;: true, &quot;host&quot;: &quot;127.0.0.1&quot;, &quot;port&quot;: 6379 } }) Methods createFileCache(options, ttl) Instantiates a FileCache and adds it to the set of CacheHandlers Parameters: Name Type Description options object the options used to create a FileCache instance, specifically `path` which determines where cached data will be stored ttl Number the time in seconds after which a cached item should be considered stale Source: index.js, line 91 Returns: Type FileCache createRedisCache(options, ttl) Instantiates a RedisCache and adds it to the set of CacheHandlers Parameters: Name Type Description options object the options used to create a RedisCache instance, specifically `host` and `port` for connecting to a Redis server ttl Number the time in seconds after which Redis should expire a cached item Source: index.js, line 105 Returns: Type RedisCache get(key) Get an item from the cache Parameters: Name Type Description key String the key used to reference the item in the cache Source: index.js, line 71 Returns: A promise that returns a Stream if the key exists, or an Error if it does not exist Type Promise.&lt;Stream, Error&gt; set(key, data) Add an item to the cache Parameters: Name Type Description key String the key used to reference the item in the cache data Buffer | Stream | String the data to store in the cache Source: index.js, line 81 Returns: A promise that returns an empty String if successful, otherwise an Error Type Promise.&lt;String, Error&gt; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"FileCache.html":{"id":"FileCache.html","title":"Class: FileCache","body":" DADI Cache Classes CacheFileCacheRedisCache Class: FileCache FileCache This is a description of the FileCache. new FileCache(options) Creates a new FileCache instance Parameters: Name Type Description options object the options used to instantiate a FileCache handler Source: file.js, line 13 Methods get(key) Parameters: Name Type Description key String the key to retrieve from cache Source: file.js, line 31 Returns: A promise that returns a Stream if the key exists, or an Error if it does not exist Type Promise.&lt;Stream, Error&gt; set(key, data) Parameters: Name Type Description key String the key to store the data against data String | Buffer | Stream the data to cache, as a String, Buffer or Stream Source: file.js, line 58 Returns: A promise that returns an empty String if successful, otherwise an Error Type Promise.&lt;String, Error&gt; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "},"RedisCache.html":{"id":"RedisCache.html","title":"Class: RedisCache","body":" DADI Cache Classes CacheFileCacheRedisCache Class: RedisCache RedisCache This is a description of the RedisCache. new RedisCache(options) Creates a new RedisCache instance Parameters: Name Type Description options object the options used to instantiate a RedisCache handler Source: redis.js, line 16 Methods get(key) Parameters: Name Type Description key String the key to retrieve from cache Source: redis.js, line 31 Returns: A promise that returns a Stream if the key exists, or an Error if it does not exist Type Promise.&lt;Stream, Error&gt; initialise() Initialises a RedisClient using the main configuration settings Source: redis.js, line 80 Returns: Type RedisClient set(key, data) Parameters: Name Type Description key String the key to store the data against data String | Buffer | Stream the data to cache, as a String, Buffer or Stream Source: redis.js, line 49 Returns: A promise that returns an empty String if successful, otherwise an Error Type Promise.&lt;String, Error&gt; × Search results Close Documentation generated by JSDoc 3.4.0 on 2016-08-01T10:19:58+08:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
